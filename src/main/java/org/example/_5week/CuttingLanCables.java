package main.java.org.example._5week;

// https://www.acmicpc.net/problem/1654
//
// 랜선 자르기
// 시간 제한	메모리 제한
// 2초 	    128MB
//
// 문제
// 집에서 시간을 보내던 오영식은 박성원의 부름을 받고 급히 달려왔다.
// 박성원이 캠프 때 쓸 N개의 랜선을 만들어야 하는데 너무 바빠서 영식이에게 도움을 청했다.
//
// 이미 오영식은 자체적으로 K개의 랜선을 가지고 있다. 그러나 K개의 랜선은 길이가 제각각이다.
// 박성원은 랜선을 모두 N개의 같은 길이의 랜선으로 만들고 싶었기 때문에 K개의 랜선을 잘라서 만들어야 한다.
// 예를 들어 300cm 짜리 랜선에서 140cm 짜리 랜선을 두 개 잘라내면 20cm는 버려야 한다. (이미 자른 랜선은 붙일 수 없다.)
//
// 편의를 위해 랜선을 자르거나 만들 때 손실되는 길이는 없다고 가정하며,
// 기존의 K개의 랜선으로 N개의 랜선을 만들 수 없는 경우는 없다고 가정하자.
// 그리고 자를 때는 항상 센티미터 단위로 정수길이만큼 자른다고 가정하자.
// N개보다 많이 만드는 것도 N개를 만드는 것에 포함된다.
// 이때 만들 수 있는 최대 랜선의 길이를 구하는 프로그램을 작성하시오.
//
// 입력
// 첫째 줄에는 오영식이 이미 가지고 있는 랜선의 개수 K, 그리고 필요한 랜선의 개수 N이 입력된다.
// K는 1이상 10,000이하의 정수이고, N은 1이상 1,000,000이하의 정수이다. 그리고 항상 K ≦ N 이다.
// 그 후 K줄에 걸쳐 이미 가지고 있는 각 랜선의 길이가 센티미터 단위의 정수로 입력된다.
// 랜선의 길이는 (2의31승)-1보다 작거나 같은 자연수이다.
//
// 출력
// 첫째 줄에 N개를 만들 수 있는 랜선의 최대 길이를 센티미터 단위의 정수로 출력한다

import java.util.*;

// 처음 생각한 방법
// 주어진 랜선의 총 길이를 모두 더한 후 필요한 랜선의 개수로 나누어 평균 길이를 구하고,
// 이를 반올림하여 시작점으로 삼은 뒤 1씩 증감하면서 최적의 길이를 찾는 방법
// --> 효율성이 떨어진다.

// 문제 해결 방법
// 이진 탐색(Binary Search) 사용을 통해 가능한 랜선의 최대 길이를 찾아내는 방법으로 접근.
//
// 랜선의 길이를 1부터 가장 긴 랜선의 길이까지로 설정한 후, 이 범위 내에서 이진 탐색 수행.
// 중간값(mid)을 구한 후, 모든 랜선을 이 길이로 잘랐을 때 몇 개의 랜선을 얻을 수 있는지 계산.
// 만약 이렇게 얻은 랜선의 개수가 필요한 랜선의 개수(N)보다 많거나 같다면,
// 랜선의 길이를 늘릴 수 있는 가능성이 있음을 의미하므로, 최소 길이를 mid + 1로 설정.
// 반대로, 얻은 랜선의 개수가 N보다 적다면, 랜선의 길이를 줄여야 하므로 최대 길이를 mid - 1로 설정.
// 이 과정을 반복하면서 최대 길이를 찾는다.

public class CuttingLanCables {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int K = sc.nextInt(); // 가지고 있는 랜선의 개수
        int N = sc.nextInt(); // 필요한 랜선의 개수
        long[] cables = new long[K];

        long max = 0;
        for (int i = 0; i < K; i++) {
            cables[i] = sc.nextLong();
            if (max < cables[i]) {
                max = cables[i]; // 가장 긴 랜선의 길이 찾기.
            }
        }

        long min = 1; // 최소 길이
        long result = 0;

        while (min <= max) {
            long mid = (min + max) / 2; // 중간 길이
            long count = 0; // 현재 길이로 잘랐을 때 얻을 수 있는 랜선의 개수

            for (long cable : cables) {
                count += cable / mid; // 각 랜선을 현재 길이로 잘라서 몇 개를 만들 수 있는지 계산
            }

            if (count >= N) { // 만들 수 있는 랜선의 개수가 필요한 개수보다 많거나 같다면
                min = mid + 1; // 더 긴 길이도 가능한지 확인
                result = mid; // 현재 길이를 결과로 저장
            } else { // 만들 수 있는 랜선의 개수가 부족하다면
                max = mid - 1; // 더 짧은 길이를 탐색
            }
        }

        System.out.println(result); // 최대 랜선의 길이를 출력
    }
}

